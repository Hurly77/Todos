create type "public"."task_repeat_type" as enum ('days', 'weeks', 'months', 'years');

drop policy "Enable read access for all users" on "public"."categories";

alter table "public"."tasks" drop constraint "tasks_categories_id_fkey";

alter table "public"."task_repeat" drop constraint "task_repeat_task_id_fkey";

alter table "public"."task_steps" drop constraint "task_steps_task_id_fkey";

alter table "public"."categories" drop constraint "categories_pkey";

drop index if exists "public"."categories_pkey";

drop table "public"."categories";

create table "public"."task_tag" (
    "red" boolean not null default false,
    "green" boolean not null default false,
    "blue" boolean not null default false,
    "yellow" boolean not null default false,
    "orange" boolean not null default false,
    "purple" boolean not null default false,
    "created_at" timestamp with time zone not null default now(),
    "id" bigint generated by default as identity not null,
    "task_id" bigint
);


alter table "public"."task_tag" enable row level security;

alter table "public"."task_repeat" add column "days" integer[];

alter table "public"."task_repeat" add column "indefinite" boolean not null default false;

alter table "public"."task_repeat" add column "interval" bigint not null default '0'::bigint;

alter table "public"."task_repeat" add column "type" task_repeat_type not null default 'days'::task_repeat_type;

alter table "public"."task_repeat" alter column "created_at" drop not null;

alter table "public"."task_steps" add column "completed" boolean not null default false;

alter table "public"."task_steps" alter column "task_id" set not null;

alter table "public"."tasks" drop column "categories_id";

alter table "public"."tasks" add column "is_my_day" boolean not null default true;

alter table "public"."tasks" add column "my_day_date" timestamp with time zone default now();

alter table "public"."tasks" add column "repeat_id" bigint;

alter table "public"."tasks" add column "tag_id" bigint;

alter table "public"."tasks" alter column "completed" set not null;

alter table "public"."tasks" alter column "created_at" drop not null;

alter table "public"."tasks" alter column "important" set not null;

alter table "public"."tasks" alter column "title" set default ''::character varying;

alter table "public"."tasks" alter column "title" set not null;

CREATE UNIQUE INDEX task_tag_pkey ON public.task_tag USING btree (id);

alter table "public"."task_tag" add constraint "task_tag_pkey" PRIMARY KEY using index "task_tag_pkey";

alter table "public"."task_tag" add constraint "task_tag_task_id_fkey" FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE not valid;

alter table "public"."task_tag" validate constraint "task_tag_task_id_fkey";

alter table "public"."tasks" add constraint "tasks_repeat_id_fkey" FOREIGN KEY (repeat_id) REFERENCES task_repeat(id) not valid;

alter table "public"."tasks" validate constraint "tasks_repeat_id_fkey";

alter table "public"."tasks" add constraint "tasks_tag_id_fkey" FOREIGN KEY (tag_id) REFERENCES task_tag(id) not valid;

alter table "public"."tasks" validate constraint "tasks_tag_id_fkey";

alter table "public"."task_repeat" add constraint "task_repeat_task_id_fkey" FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE not valid;

alter table "public"."task_repeat" validate constraint "task_repeat_task_id_fkey";

alter table "public"."task_steps" add constraint "task_steps_task_id_fkey" FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE not valid;

alter table "public"."task_steps" validate constraint "task_steps_task_id_fkey";

create policy "Enable Update for users based on user_id"
on "public"."task_repeat"
as permissive
for update
to public
using ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (tasks.repeat_id = task_repeat.id))))
with check ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (tasks.repeat_id = task_repeat.id))));


create policy "Enable delete for users based on user_id"
on "public"."task_repeat"
as permissive
for delete
to public
using ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (tasks.repeat_id = task_repeat.id))));


create policy "Enable insert for authenticated users only"
on "public"."task_repeat"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable delete for users based on user_id"
on "public"."task_steps"
as permissive
for delete
to public
using ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (task_steps.task_id = tasks.id))));


create policy "Enable insert for authenticated users only"
on "public"."task_steps"
as permissive
for insert
to authenticated
with check ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (task_steps.task_id = tasks.id))));


create policy "Enable update for users based on  user_id"
on "public"."task_steps"
as permissive
for update
to public
using ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (task_steps.task_id = tasks.id))))
with check ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (task_steps.task_id = tasks.id))));


create policy "Enable insert for authenticated users only"
on "public"."task_tag"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."task_tag"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on email"
on "public"."task_tag"
as permissive
for update
to public
using ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (tasks.id = task_tag.task_id))))
with check ((auth.uid() = ( SELECT tasks.user_id
   FROM tasks
  WHERE (tasks.id = task_tag.task_id))));


create policy "Enable delete for users based on user_id"
on "public"."tasks"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Enable update for users based on user_id"
on "public"."tasks"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



